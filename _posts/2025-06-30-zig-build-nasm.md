---
title: Embedding machine code with Zig Build System
layout: post
comments: true
hidden: true
---

For purposes that would become clear in a future post, I needed to solve a curious problem in the Zig build system. Prior to that, I knew very little about it. I expected the problem to be easy to solve, and it quite is, but boy, I have learned a lot in the process. With much of poking into existing guides, reading the source, hammering chatbots, trial and error, and a bit of luck, I arrived at the solution.

The problem goes as follows. I want to assemble an assembly listing (with `nasm`) and embed the machine code in the Zig program to be able to manipulate it as plain bytes. The curious part is that I want to utilize the build system to automate the process and cache/rebuild as needed.

For pedagogical reasons, I would try to present a more or less linear story with a few shoot-offs in an order that somewhat resembles the order I discovered the things.

### Disclaimer

I'm still very new to Zig and its tooling so I might have gotten many things wrong.

Moreover, this is a very convoluted way to get assembly in your program. If you just want to implement some routines in assembly, assemble the listings into an object file and link against it.

With the ceremony out of the way, there is the story.

## Existing references

I won't give a ground-up introduction to the Zig build system. There are already awesome guides and resources to get started:
  - [zig build explained (in 3 parts)](https://zig.news/xq/zig-build-explained-part-1-59lf)
  - [Zig Build System Internals](https://mitchellh.com/zig/build-internals) by Mitchell Hashimoto
  - [Zig Build System Basics](https://www.youtube.com/watch?v=jy7w_7JZYyw) by [Loris Cro](https://github.com/kristoff-it)

I would like to build on top of them, and show some other details.

## Here the story goes

Let's start with the basic setup.

`src/main.zig`:
```zig
const std = @import("std");

pub fn main() !void {
    var stdout = std.io.getStdOut().writer();
    for (bytes) |b| {
        try stdout.print("{x:0>2}", .{b});
    }
    try stdout.writeAll("\n");
}

const bytes = @embedFile("example.bin");
```

`src/example.asm`:
```nasm
add rax, 5
```

`build.zig`:
```zig
const std = @import("std");

pub fn build(b: *std.Build) void {
    const target = b.standardTargetOptions(.{});
    const optimize = b.standardOptimizeOption(.{});

    const exe_mod = b.createModule(.{
        .root_source_file = b.path("src/main.zig"),
        .target = target,
        .optimize = optimize,
    });

    const exe = b.addExecutable(.{
        .name = "embed-example",
        .root_module = exe_mod,
    });

    b.installArtifact(exe);

    const run_cmd = b.addRunArtifact(exe);

    if (b.args) |args| {
        run_cmd.addArgs(args);
    }

    run_cmd.step.dependOn(b.getInstallStep());

    const run_step = b.step("run", "Run the program");
    run_step.dependOn(&run_cmd.step);
}
```







Brain dump:
- The problem: want to manipulate a sequence of machine code bytes in a zig program. I want to automate the process and reassemble the machine code if the assembly changes. I want to recompile the program in that case as well.
- Disclaimer:
  - I don't know what I'm doing
  - if you just want to call assembly from a zig source file, assemble an object file and link against it
  - we will delve into the details of the zig build system. if you just want the solution, jump to the *section*(link).
  - this post will be written more or less in the order I discovered these features

<!--break-->

- Existing references:
  - [zig build explained (in 3 parts)](https://zig.news/xq/zig-build-explained-part-1-59lf)
  - [Zig Build System Internals](https://mitchellh.com/zig/build-internals) by Mitchell Hashimoto
  - [Zig Build System Basics](https://www.youtube.com/watch?v=jy7w_7JZYyw) by [Loris Cro](https://github.com/kristoff-it)
- two-phase: declarative building of a graph of steps, and execution in `make` (TODO: WHY?)
- zig-cache
  - the compiler is deterministic. if you feed the same inputs, you get the same outputs,
    so we can cache the outputs and reference them by the inputs
  - this is an hash-keyed store
  - `o/<hash>/...`
  - the hash hashes all inputs: all parameters, settings, input file paths, and their contents
  - TODO: what if we crash midway?
- the crude version of `addSystemCommand` with hard coded path
  - `addAnonymousModule`: this is a hack because this is not zig source code but there is [an example](https://gist.github.com/andrewrk/d1e6173448ab2bc350233cc20025ba56) by Andrew Kelley himself, so seems legit.
  - problems:
    1. we have to explicitly tie the dependency on the `nasm` step. if we forget, the build system may try to run these steps in parallel because it doesn't know that the input file is generated by another step
    2. we put our output file in the source tree.
      This might be a desirable behavior, if you generate source code, and want to commit and diff it.
      but here this is just a part of the build process, we don't need this file anywhere else
    3. the command gets run on each `zig build` (TODO: WHY) but it doesn't get rerun in the `--watch` mode when the input file changes because the build system doesn't know the command depends on this file
- solving problem 1. Lazy path
  - alloc `GeneratedFile` + explicit `.generated`
  - seems hacky
- how to solve problem 2?
  - we want to put the output file somewhere among other build artifacts in `zig-cache`
  - a try with `tmp` folder. Works but gets rebuild each time because the key changes
  - the solution: `addOutputFileArg`
    - returns `*GeneratedFile`
    - this is where `LazyPath` shines
    - this is a pointer somewhere within this step
    - actual path is `null`, because the placement in the cache is determined later
    - the step will fill in the path later, during `make`, when the cache key becomes known
- how to solve problem 3?
  - similar `addFileArg`
  - it add adds an argument and adds a dependency on it
  - TODO: TEST THIS
- conclusion
  - final gist
  - i really love the zig build system
  - it is very powerful and allows to compose any external dependencies with the zig compiler
  - it even easily allows to build tools written in zig from source and run them as a part of the build process (TODO: LINK TO EXAMPLE)
  - and it is not obscenly complicated: a few key abstractions and ideas, and you are good to go.
  - what could be done better:
    - docs. existing resources are of help, but a comprehensive official documentation with reference, explanation of concepts, and a cookbook for common use cases will be of great help
    - maybe not right now because the lang changes frequently
